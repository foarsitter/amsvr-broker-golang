/*
AMSVR Broker API

# Introductie     Voor u heeft u de online documentatie van de AMSVR Broker API. Omdat het een Nederlands domein      betreft worden er Engelse en Nederlandse terminologie door elkaar heen gebruikt.  Liefhebbers van de Swagger UI kunnen [hier terecht](/swagger-ui). Daarnaast is de API eveneens beschikbaar in de op endpoint niveau zoals bijvoorbeeld [hier](/api/aansluitingen).  ##        

API version: release-0.6.14
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package broker

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// SectorenApiService SectorenApi service
type SectorenApiService service

type ApiAansluitingenSectorenCreateRequest struct {
	ctx context.Context
	ApiService *SectorenApiService
	aansluitnummer string
	sectorRequest *SectorRequest
}

func (r ApiAansluitingenSectorenCreateRequest) SectorRequest(sectorRequest SectorRequest) ApiAansluitingenSectorenCreateRequest {
	r.sectorRequest = &sectorRequest
	return r
}

func (r ApiAansluitingenSectorenCreateRequest) Execute() (*Sector, *http.Response, error) {
	return r.ApiService.AansluitingenSectorenCreateExecute(r)
}

/*
AansluitingenSectorenCreate Method for AansluitingenSectorenCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenSectorenCreateRequest
*/
func (a *SectorenApiService) AansluitingenSectorenCreate(ctx context.Context, aansluitnummer string) ApiAansluitingenSectorenCreateRequest {
	return ApiAansluitingenSectorenCreateRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return Sector
func (a *SectorenApiService) AansluitingenSectorenCreateExecute(r ApiAansluitingenSectorenCreateRequest) (*Sector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Sector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SectorenApiService.AansluitingenSectorenCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/sectoren"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sectorRequest == nil {
		return localVarReturnValue, nil, reportError("sectorRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sectorRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenSectorenDestroyRequest struct {
	ctx context.Context
	ApiService *SectorenApiService
	id int32
}

func (r ApiAansluitingenSectorenDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.AansluitingenSectorenDestroyExecute(r)
}

/*
AansluitingenSectorenDestroy Method for AansluitingenSectorenDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiAansluitingenSectorenDestroyRequest
*/
func (a *SectorenApiService) AansluitingenSectorenDestroy(ctx context.Context, id int32) ApiAansluitingenSectorenDestroyRequest {
	return ApiAansluitingenSectorenDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SectorenApiService) AansluitingenSectorenDestroyExecute(r ApiAansluitingenSectorenDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SectorenApiService.AansluitingenSectorenDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/sectoren/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAansluitingenSectorenListRequest struct {
	ctx context.Context
	ApiService *SectorenApiService
	aansluitnummer string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiAansluitingenSectorenListRequest) Limit(limit int32) ApiAansluitingenSectorenListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiAansluitingenSectorenListRequest) Offset(offset int32) ApiAansluitingenSectorenListRequest {
	r.offset = &offset
	return r
}

func (r ApiAansluitingenSectorenListRequest) Execute() (*PaginatedSectorList, *http.Response, error) {
	return r.ApiService.AansluitingenSectorenListExecute(r)
}

/*
AansluitingenSectorenList Method for AansluitingenSectorenList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenSectorenListRequest
*/
func (a *SectorenApiService) AansluitingenSectorenList(ctx context.Context, aansluitnummer string) ApiAansluitingenSectorenListRequest {
	return ApiAansluitingenSectorenListRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return PaginatedSectorList
func (a *SectorenApiService) AansluitingenSectorenListExecute(r ApiAansluitingenSectorenListRequest) (*PaginatedSectorList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedSectorList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SectorenApiService.AansluitingenSectorenList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/sectoren"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenSectorenRetrieveByIdRequest struct {
	ctx context.Context
	ApiService *SectorenApiService
	id int32
}

func (r ApiAansluitingenSectorenRetrieveByIdRequest) Execute() (*Sector, *http.Response, error) {
	return r.ApiService.AansluitingenSectorenRetrieveByIdExecute(r)
}

/*
AansluitingenSectorenRetrieveById Method for AansluitingenSectorenRetrieveById

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiAansluitingenSectorenRetrieveByIdRequest
*/
func (a *SectorenApiService) AansluitingenSectorenRetrieveById(ctx context.Context, id int32) ApiAansluitingenSectorenRetrieveByIdRequest {
	return ApiAansluitingenSectorenRetrieveByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Sector
func (a *SectorenApiService) AansluitingenSectorenRetrieveByIdExecute(r ApiAansluitingenSectorenRetrieveByIdRequest) (*Sector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Sector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SectorenApiService.AansluitingenSectorenRetrieveById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/sectoren/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenSectorenToestandPartialUpdateByIdRequest struct {
	ctx context.Context
	ApiService *SectorenApiService
	id int32
	patchedSectorToestandRequest *PatchedSectorToestandRequest
}

func (r ApiAansluitingenSectorenToestandPartialUpdateByIdRequest) PatchedSectorToestandRequest(patchedSectorToestandRequest PatchedSectorToestandRequest) ApiAansluitingenSectorenToestandPartialUpdateByIdRequest {
	r.patchedSectorToestandRequest = &patchedSectorToestandRequest
	return r
}

func (r ApiAansluitingenSectorenToestandPartialUpdateByIdRequest) Execute() (*SectorToestand, *http.Response, error) {
	return r.ApiService.AansluitingenSectorenToestandPartialUpdateByIdExecute(r)
}

/*
AansluitingenSectorenToestandPartialUpdateById Method for AansluitingenSectorenToestandPartialUpdateById

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiAansluitingenSectorenToestandPartialUpdateByIdRequest
*/
func (a *SectorenApiService) AansluitingenSectorenToestandPartialUpdateById(ctx context.Context, id int32) ApiAansluitingenSectorenToestandPartialUpdateByIdRequest {
	return ApiAansluitingenSectorenToestandPartialUpdateByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SectorToestand
func (a *SectorenApiService) AansluitingenSectorenToestandPartialUpdateByIdExecute(r ApiAansluitingenSectorenToestandPartialUpdateByIdRequest) (*SectorToestand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SectorToestand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SectorenApiService.AansluitingenSectorenToestandPartialUpdateById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/sectoren/{id}/toestand"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSectorToestandRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenSectorenUpdateRequest struct {
	ctx context.Context
	ApiService *SectorenApiService
	id int32
	sectorWriteRequest *SectorWriteRequest
}

func (r ApiAansluitingenSectorenUpdateRequest) SectorWriteRequest(sectorWriteRequest SectorWriteRequest) ApiAansluitingenSectorenUpdateRequest {
	r.sectorWriteRequest = &sectorWriteRequest
	return r
}

func (r ApiAansluitingenSectorenUpdateRequest) Execute() (*SectorWrite, *http.Response, error) {
	return r.ApiService.AansluitingenSectorenUpdateExecute(r)
}

/*
AansluitingenSectorenUpdate Method for AansluitingenSectorenUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiAansluitingenSectorenUpdateRequest
*/
func (a *SectorenApiService) AansluitingenSectorenUpdate(ctx context.Context, id int32) ApiAansluitingenSectorenUpdateRequest {
	return ApiAansluitingenSectorenUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SectorWrite
func (a *SectorenApiService) AansluitingenSectorenUpdateExecute(r ApiAansluitingenSectorenUpdateRequest) (*SectorWrite, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SectorWrite
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SectorenApiService.AansluitingenSectorenUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/sectoren/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sectorWriteRequest == nil {
		return localVarReturnValue, nil, reportError("sectorWriteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sectorWriteRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSectorListRequest struct {
	ctx context.Context
	ApiService *SectorenApiService
	bagNietBeschikbaar *bool
	huisnummer *string
	isBouwdeelNull *bool
	limit *int32
	modifiedAfter *string
	modifiedBefore *string
	naam *string
	nummer *int32
	offset *int32
	postcode *string
}

func (r ApiSectorListRequest) BagNietBeschikbaar(bagNietBeschikbaar bool) ApiSectorListRequest {
	r.bagNietBeschikbaar = &bagNietBeschikbaar
	return r
}

func (r ApiSectorListRequest) Huisnummer(huisnummer string) ApiSectorListRequest {
	r.huisnummer = &huisnummer
	return r
}

func (r ApiSectorListRequest) IsBouwdeelNull(isBouwdeelNull bool) ApiSectorListRequest {
	r.isBouwdeelNull = &isBouwdeelNull
	return r
}

// Number of results to return per page.
func (r ApiSectorListRequest) Limit(limit int32) ApiSectorListRequest {
	r.limit = &limit
	return r
}

func (r ApiSectorListRequest) ModifiedAfter(modifiedAfter string) ApiSectorListRequest {
	r.modifiedAfter = &modifiedAfter
	return r
}

func (r ApiSectorListRequest) ModifiedBefore(modifiedBefore string) ApiSectorListRequest {
	r.modifiedBefore = &modifiedBefore
	return r
}

// Naam
func (r ApiSectorListRequest) Naam(naam string) ApiSectorListRequest {
	r.naam = &naam
	return r
}

func (r ApiSectorListRequest) Nummer(nummer int32) ApiSectorListRequest {
	r.nummer = &nummer
	return r
}

// The initial index from which to return the results.
func (r ApiSectorListRequest) Offset(offset int32) ApiSectorListRequest {
	r.offset = &offset
	return r
}

// Postcode
func (r ApiSectorListRequest) Postcode(postcode string) ApiSectorListRequest {
	r.postcode = &postcode
	return r
}

func (r ApiSectorListRequest) Execute() (*PaginatedSectorList, *http.Response, error) {
	return r.ApiService.SectorListExecute(r)
}

/*
SectorList Method for SectorList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSectorListRequest
*/
func (a *SectorenApiService) SectorList(ctx context.Context) ApiSectorListRequest {
	return ApiSectorListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedSectorList
func (a *SectorenApiService) SectorListExecute(r ApiSectorListRequest) (*PaginatedSectorList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedSectorList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SectorenApiService.SectorList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/sectoren"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bagNietBeschikbaar != nil {
		localVarQueryParams.Add("bag_niet_beschikbaar", parameterToString(*r.bagNietBeschikbaar, ""))
	}
	if r.huisnummer != nil {
		localVarQueryParams.Add("huisnummer", parameterToString(*r.huisnummer, ""))
	}
	if r.isBouwdeelNull != nil {
		localVarQueryParams.Add("is_bouwdeel_null", parameterToString(*r.isBouwdeelNull, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.modifiedAfter != nil {
		localVarQueryParams.Add("modified_after", parameterToString(*r.modifiedAfter, ""))
	}
	if r.modifiedBefore != nil {
		localVarQueryParams.Add("modified_before", parameterToString(*r.modifiedBefore, ""))
	}
	if r.naam != nil {
		localVarQueryParams.Add("naam", parameterToString(*r.naam, ""))
	}
	if r.nummer != nil {
		localVarQueryParams.Add("nummer", parameterToString(*r.nummer, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.postcode != nil {
		localVarQueryParams.Add("postcode", parameterToString(*r.postcode, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
