/*
AMSVR Broker API

# Introductie     Voor u heeft u de online documentatie van de AMSVR Broker API. Omdat het een Nederlands domein      betreft worden er Engelse en Nederlandse terminologie door elkaar heen gebruikt.  Liefhebbers van de Swagger UI kunnen [hier terecht](/swagger-ui). Daarnaast is de API eveneens beschikbaar in de op endpoint niveau zoals bijvoorbeeld [hier](/api/aansluitingen).  ##        

API version: release-0.6.14
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package broker

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// AansluitingenApiService AansluitingenApi service
type AansluitingenApiService service

type ApiAansluitingenContactpersonenCreateRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
	contactPersoonRequest *ContactPersoonRequest
}

func (r ApiAansluitingenContactpersonenCreateRequest) ContactPersoonRequest(contactPersoonRequest ContactPersoonRequest) ApiAansluitingenContactpersonenCreateRequest {
	r.contactPersoonRequest = &contactPersoonRequest
	return r
}

func (r ApiAansluitingenContactpersonenCreateRequest) Execute() (*ContactPersoon, *http.Response, error) {
	return r.ApiService.AansluitingenContactpersonenCreateExecute(r)
}

/*
AansluitingenContactpersonenCreate Method for AansluitingenContactpersonenCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenContactpersonenCreateRequest
*/
func (a *AansluitingenApiService) AansluitingenContactpersonenCreate(ctx context.Context, aansluitnummer string) ApiAansluitingenContactpersonenCreateRequest {
	return ApiAansluitingenContactpersonenCreateRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return ContactPersoon
func (a *AansluitingenApiService) AansluitingenContactpersonenCreateExecute(r ApiAansluitingenContactpersonenCreateRequest) (*ContactPersoon, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContactPersoon
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenContactpersonenCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/contactpersonen"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contactPersoonRequest == nil {
		return localVarReturnValue, nil, reportError("contactPersoonRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contactPersoonRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenContactpersonenListRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiAansluitingenContactpersonenListRequest) Limit(limit int32) ApiAansluitingenContactpersonenListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiAansluitingenContactpersonenListRequest) Offset(offset int32) ApiAansluitingenContactpersonenListRequest {
	r.offset = &offset
	return r
}

func (r ApiAansluitingenContactpersonenListRequest) Execute() (*PaginatedContactPersoonList, *http.Response, error) {
	return r.ApiService.AansluitingenContactpersonenListExecute(r)
}

/*
AansluitingenContactpersonenList Method for AansluitingenContactpersonenList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenContactpersonenListRequest
*/
func (a *AansluitingenApiService) AansluitingenContactpersonenList(ctx context.Context, aansluitnummer string) ApiAansluitingenContactpersonenListRequest {
	return ApiAansluitingenContactpersonenListRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return PaginatedContactPersoonList
func (a *AansluitingenApiService) AansluitingenContactpersonenListExecute(r ApiAansluitingenContactpersonenListRequest) (*PaginatedContactPersoonList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedContactPersoonList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenContactpersonenList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/contactpersonen"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenCreateRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitingRequest *AansluitingRequest
}

func (r ApiAansluitingenCreateRequest) AansluitingRequest(aansluitingRequest AansluitingRequest) ApiAansluitingenCreateRequest {
	r.aansluitingRequest = &aansluitingRequest
	return r
}

func (r ApiAansluitingenCreateRequest) Execute() (*Aansluiting, *http.Response, error) {
	return r.ApiService.AansluitingenCreateExecute(r)
}

/*
AansluitingenCreate Method for AansluitingenCreate


# Gegevensvalidatie adressering
Om te voorkomen dat er fouten ontstaan in de adressering van aansluitingen worden adressen gevalideerd in de BAG.
Hiervoor wordt de API Locatieserver van PDOK gebruikt. Deze dienst is vrijelijk
te gebruiken: https://github.com/PDOK/locatieserver/wiki/API-Locatieserver

Er zijn drie verschillende wegen om een aansluiting correct toe te voegen.

1. Lookup met bag_lookup_id: via deze methode is het mogelijk om zelf suggesties op te vragen bij de PDOK Locatieserver.
Vervolgens halen wij aan onze kant de gevens uit de BAG. Meegestuurde waarden worden voor
 bijvoorbeeld huisnummer worden genegeerd.

2. Suggest via Postcode en huisnummer (en optioneel straat, huisletter en toevoeging):
via deze methode proberen wij te matchen met de BAG.
Als er een match wordt gevonden dan worden de gevens uit BAG als leidend beschouwd.

3. bag_niet_beschikbaar = True: hierbij wordt een motivatie verwacht in het bag_comment veld. Deze is verplicht.
Adresvelden worden via deze weg niet gevalideerd. Wel is het noodzakelijk om de juiste gemeente op te geven.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAansluitingenCreateRequest
*/
func (a *AansluitingenApiService) AansluitingenCreate(ctx context.Context) ApiAansluitingenCreateRequest {
	return ApiAansluitingenCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Aansluiting
func (a *AansluitingenApiService) AansluitingenCreateExecute(r ApiAansluitingenCreateRequest) (*Aansluiting, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aansluiting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aansluitingRequest == nil {
		return localVarReturnValue, nil, reportError("aansluitingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aansluitingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenDestroyRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
}

func (r ApiAansluitingenDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.AansluitingenDestroyExecute(r)
}

/*
AansluitingenDestroy Method for AansluitingenDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenDestroyRequest
*/
func (a *AansluitingenApiService) AansluitingenDestroy(ctx context.Context, aansluitnummer string) ApiAansluitingenDestroyRequest {
	return ApiAansluitingenDestroyRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
func (a *AansluitingenApiService) AansluitingenDestroyExecute(r ApiAansluitingenDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAansluitingenListRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer *string
	atsp *int32
	bijzonderheden *bool
	createdAfter *time.Time
	createdBefore *time.Time
	gebruiksfunctie *string
	gemeente *int32
	isTestAansluiting *bool
	limit *int32
	modifiedAfter *time.Time
	modifiedBefore *time.Time
	naam *string
	offset *int32
	plaats *string
	postcode *string
	straat *string
	testExpired *bool
}

// Aansluitnummer
func (r ApiAansluitingenListRequest) Aansluitnummer(aansluitnummer string) ApiAansluitingenListRequest {
	r.aansluitnummer = &aansluitnummer
	return r
}

func (r ApiAansluitingenListRequest) Atsp(atsp int32) ApiAansluitingenListRequest {
	r.atsp = &atsp
	return r
}

// Heeft bijzonderheden
func (r ApiAansluitingenListRequest) Bijzonderheden(bijzonderheden bool) ApiAansluitingenListRequest {
	r.bijzonderheden = &bijzonderheden
	return r
}

func (r ApiAansluitingenListRequest) CreatedAfter(createdAfter time.Time) ApiAansluitingenListRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r ApiAansluitingenListRequest) CreatedBefore(createdBefore time.Time) ApiAansluitingenListRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r ApiAansluitingenListRequest) Gebruiksfunctie(gebruiksfunctie string) ApiAansluitingenListRequest {
	r.gebruiksfunctie = &gebruiksfunctie
	return r
}

func (r ApiAansluitingenListRequest) Gemeente(gemeente int32) ApiAansluitingenListRequest {
	r.gemeente = &gemeente
	return r
}

func (r ApiAansluitingenListRequest) IsTestAansluiting(isTestAansluiting bool) ApiAansluitingenListRequest {
	r.isTestAansluiting = &isTestAansluiting
	return r
}

// Number of results to return per page.
func (r ApiAansluitingenListRequest) Limit(limit int32) ApiAansluitingenListRequest {
	r.limit = &limit
	return r
}

func (r ApiAansluitingenListRequest) ModifiedAfter(modifiedAfter time.Time) ApiAansluitingenListRequest {
	r.modifiedAfter = &modifiedAfter
	return r
}

func (r ApiAansluitingenListRequest) ModifiedBefore(modifiedBefore time.Time) ApiAansluitingenListRequest {
	r.modifiedBefore = &modifiedBefore
	return r
}

// Naam
func (r ApiAansluitingenListRequest) Naam(naam string) ApiAansluitingenListRequest {
	r.naam = &naam
	return r
}

// The initial index from which to return the results.
func (r ApiAansluitingenListRequest) Offset(offset int32) ApiAansluitingenListRequest {
	r.offset = &offset
	return r
}

// Plaats
func (r ApiAansluitingenListRequest) Plaats(plaats string) ApiAansluitingenListRequest {
	r.plaats = &plaats
	return r
}

// Postcode
func (r ApiAansluitingenListRequest) Postcode(postcode string) ApiAansluitingenListRequest {
	r.postcode = &postcode
	return r
}

// Straat
func (r ApiAansluitingenListRequest) Straat(straat string) ApiAansluitingenListRequest {
	r.straat = &straat
	return r
}

// Testperiode verlopen
func (r ApiAansluitingenListRequest) TestExpired(testExpired bool) ApiAansluitingenListRequest {
	r.testExpired = &testExpired
	return r
}

func (r ApiAansluitingenListRequest) Execute() (*PaginatedAansluitingList, *http.Response, error) {
	return r.ApiService.AansluitingenListExecute(r)
}

/*
AansluitingenList Method for AansluitingenList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAansluitingenListRequest
*/
func (a *AansluitingenApiService) AansluitingenList(ctx context.Context) ApiAansluitingenListRequest {
	return ApiAansluitingenListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedAansluitingList
func (a *AansluitingenApiService) AansluitingenListExecute(r ApiAansluitingenListRequest) (*PaginatedAansluitingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedAansluitingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.aansluitnummer != nil {
		localVarQueryParams.Add("aansluitnummer", parameterToString(*r.aansluitnummer, ""))
	}
	if r.atsp != nil {
		localVarQueryParams.Add("atsp", parameterToString(*r.atsp, ""))
	}
	if r.bijzonderheden != nil {
		localVarQueryParams.Add("bijzonderheden", parameterToString(*r.bijzonderheden, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("created_after", parameterToString(*r.createdAfter, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("created_before", parameterToString(*r.createdBefore, ""))
	}
	if r.gebruiksfunctie != nil {
		localVarQueryParams.Add("gebruiksfunctie", parameterToString(*r.gebruiksfunctie, ""))
	}
	if r.gemeente != nil {
		localVarQueryParams.Add("gemeente", parameterToString(*r.gemeente, ""))
	}
	if r.isTestAansluiting != nil {
		localVarQueryParams.Add("is_test_aansluiting", parameterToString(*r.isTestAansluiting, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.modifiedAfter != nil {
		localVarQueryParams.Add("modified_after", parameterToString(*r.modifiedAfter, ""))
	}
	if r.modifiedBefore != nil {
		localVarQueryParams.Add("modified_before", parameterToString(*r.modifiedBefore, ""))
	}
	if r.naam != nil {
		localVarQueryParams.Add("naam", parameterToString(*r.naam, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.plaats != nil {
		localVarQueryParams.Add("plaats", parameterToString(*r.plaats, ""))
	}
	if r.postcode != nil {
		localVarQueryParams.Add("postcode", parameterToString(*r.postcode, ""))
	}
	if r.straat != nil {
		localVarQueryParams.Add("straat", parameterToString(*r.straat, ""))
	}
	if r.testExpired != nil {
		localVarQueryParams.Add("test_expired", parameterToString(*r.testExpired, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenLopendeZaakRetrieveRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
}

func (r ApiAansluitingenLopendeZaakRetrieveRequest) Execute() (*Zaak, *http.Response, error) {
	return r.ApiService.AansluitingenLopendeZaakRetrieveExecute(r)
}

/*
AansluitingenLopendeZaakRetrieve Method for AansluitingenLopendeZaakRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenLopendeZaakRetrieveRequest
*/
func (a *AansluitingenApiService) AansluitingenLopendeZaakRetrieve(ctx context.Context, aansluitnummer string) ApiAansluitingenLopendeZaakRetrieveRequest {
	return ApiAansluitingenLopendeZaakRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return Zaak
func (a *AansluitingenApiService) AansluitingenLopendeZaakRetrieveExecute(r ApiAansluitingenLopendeZaakRetrieveRequest) (*Zaak, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Zaak
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenLopendeZaakRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/lopende-zaak"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenMeldingenCreateRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
	meldingRequest *MeldingRequest
}

func (r ApiAansluitingenMeldingenCreateRequest) MeldingRequest(meldingRequest MeldingRequest) ApiAansluitingenMeldingenCreateRequest {
	r.meldingRequest = &meldingRequest
	return r
}

func (r ApiAansluitingenMeldingenCreateRequest) Execute() (*Melding, *http.Response, error) {
	return r.ApiService.AansluitingenMeldingenCreateExecute(r)
}

/*
AansluitingenMeldingenCreate Method for AansluitingenMeldingenCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenMeldingenCreateRequest
*/
func (a *AansluitingenApiService) AansluitingenMeldingenCreate(ctx context.Context, aansluitnummer string) ApiAansluitingenMeldingenCreateRequest {
	return ApiAansluitingenMeldingenCreateRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return Melding
func (a *AansluitingenApiService) AansluitingenMeldingenCreateExecute(r ApiAansluitingenMeldingenCreateRequest) (*Melding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Melding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenMeldingenCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/meldingen"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.meldingRequest == nil {
		return localVarReturnValue, nil, reportError("meldingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.meldingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenMeldingenListRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiAansluitingenMeldingenListRequest) Limit(limit int32) ApiAansluitingenMeldingenListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiAansluitingenMeldingenListRequest) Offset(offset int32) ApiAansluitingenMeldingenListRequest {
	r.offset = &offset
	return r
}

func (r ApiAansluitingenMeldingenListRequest) Execute() (*PaginatedMeldingList, *http.Response, error) {
	return r.ApiService.AansluitingenMeldingenListExecute(r)
}

/*
AansluitingenMeldingenList Method for AansluitingenMeldingenList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenMeldingenListRequest
*/
func (a *AansluitingenApiService) AansluitingenMeldingenList(ctx context.Context, aansluitnummer string) ApiAansluitingenMeldingenListRequest {
	return ApiAansluitingenMeldingenListRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return PaginatedMeldingList
func (a *AansluitingenApiService) AansluitingenMeldingenListExecute(r ApiAansluitingenMeldingenListRequest) (*PaginatedMeldingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedMeldingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenMeldingenList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/meldingen"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenMigratieCreateRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
	migratieRequest *MigratieRequest
}

func (r ApiAansluitingenMigratieCreateRequest) MigratieRequest(migratieRequest MigratieRequest) ApiAansluitingenMigratieCreateRequest {
	r.migratieRequest = &migratieRequest
	return r
}

func (r ApiAansluitingenMigratieCreateRequest) Execute() (*Aansluiting, *http.Response, error) {
	return r.ApiService.AansluitingenMigratieCreateExecute(r)
}

/*
AansluitingenMigratieCreate Method for AansluitingenMigratieCreate

Het is mogelijk om een bestaande aansluiting over te nemen van een andere ATSP. Ter verificatie vragen wij om straat + huisnummer (zonder toevoegingen)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenMigratieCreateRequest
*/
func (a *AansluitingenApiService) AansluitingenMigratieCreate(ctx context.Context, aansluitnummer string) ApiAansluitingenMigratieCreateRequest {
	return ApiAansluitingenMigratieCreateRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return Aansluiting
func (a *AansluitingenApiService) AansluitingenMigratieCreateExecute(r ApiAansluitingenMigratieCreateRequest) (*Aansluiting, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aansluiting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenMigratieCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/migratie"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.migratieRequest == nil {
		return localVarReturnValue, nil, reportError("migratieRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.migratieRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenRetrieveRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
}

func (r ApiAansluitingenRetrieveRequest) Execute() (*Aansluiting, *http.Response, error) {
	return r.ApiService.AansluitingenRetrieveExecute(r)
}

/*
AansluitingenRetrieve Method for AansluitingenRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenRetrieveRequest
*/
func (a *AansluitingenApiService) AansluitingenRetrieve(ctx context.Context, aansluitnummer string) ApiAansluitingenRetrieveRequest {
	return ApiAansluitingenRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return Aansluiting
func (a *AansluitingenApiService) AansluitingenRetrieveExecute(r ApiAansluitingenRetrieveRequest) (*Aansluiting, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aansluiting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenSearchRetrieveRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
}

func (r ApiAansluitingenSearchRetrieveRequest) Execute() (*Search, *http.Response, error) {
	return r.ApiService.AansluitingenSearchRetrieveExecute(r)
}

/*
AansluitingenSearchRetrieve Method for AansluitingenSearchRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAansluitingenSearchRetrieveRequest
*/
func (a *AansluitingenApiService) AansluitingenSearchRetrieve(ctx context.Context) ApiAansluitingenSearchRetrieveRequest {
	return ApiAansluitingenSearchRetrieveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Search
func (a *AansluitingenApiService) AansluitingenSearchRetrieveExecute(r ApiAansluitingenSearchRetrieveRequest) (*Search, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Search
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenSearchRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenSectorenRetrieveRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
	nummer int32
}

func (r ApiAansluitingenSectorenRetrieveRequest) Execute() (*Sector, *http.Response, error) {
	return r.ApiService.AansluitingenSectorenRetrieveExecute(r)
}

/*
AansluitingenSectorenRetrieve Method for AansluitingenSectorenRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @param nummer
 @return ApiAansluitingenSectorenRetrieveRequest
*/
func (a *AansluitingenApiService) AansluitingenSectorenRetrieve(ctx context.Context, aansluitnummer string, nummer int32) ApiAansluitingenSectorenRetrieveRequest {
	return ApiAansluitingenSectorenRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
		nummer: nummer,
	}
}

// Execute executes the request
//  @return Sector
func (a *AansluitingenApiService) AansluitingenSectorenRetrieveExecute(r ApiAansluitingenSectorenRetrieveRequest) (*Sector, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Sector
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenSectorenRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/sectoren/{nummer}"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nummer"+"}", url.PathEscape(parameterToString(r.nummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenSectorenToestandPartialUpdateRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
	patchedSectorToestandRequest *PatchedSectorToestandRequest
}

func (r ApiAansluitingenSectorenToestandPartialUpdateRequest) PatchedSectorToestandRequest(patchedSectorToestandRequest PatchedSectorToestandRequest) ApiAansluitingenSectorenToestandPartialUpdateRequest {
	r.patchedSectorToestandRequest = &patchedSectorToestandRequest
	return r
}

func (r ApiAansluitingenSectorenToestandPartialUpdateRequest) Execute() (*SectorToestand, *http.Response, error) {
	return r.ApiService.AansluitingenSectorenToestandPartialUpdateExecute(r)
}

/*
AansluitingenSectorenToestandPartialUpdate Method for AansluitingenSectorenToestandPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenSectorenToestandPartialUpdateRequest
*/
func (a *AansluitingenApiService) AansluitingenSectorenToestandPartialUpdate(ctx context.Context, aansluitnummer string) ApiAansluitingenSectorenToestandPartialUpdateRequest {
	return ApiAansluitingenSectorenToestandPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return SectorToestand
func (a *AansluitingenApiService) AansluitingenSectorenToestandPartialUpdateExecute(r ApiAansluitingenSectorenToestandPartialUpdateRequest) (*SectorToestand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SectorToestand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenSectorenToestandPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/sectoren/toestand"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSectorToestandRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenSectorenToestandPartialUpdate2Request struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
	nummer int32
	patchedSectorToestandRequest *PatchedSectorToestandRequest
}

func (r ApiAansluitingenSectorenToestandPartialUpdate2Request) PatchedSectorToestandRequest(patchedSectorToestandRequest PatchedSectorToestandRequest) ApiAansluitingenSectorenToestandPartialUpdate2Request {
	r.patchedSectorToestandRequest = &patchedSectorToestandRequest
	return r
}

func (r ApiAansluitingenSectorenToestandPartialUpdate2Request) Execute() (*SectorToestand, *http.Response, error) {
	return r.ApiService.AansluitingenSectorenToestandPartialUpdate2Execute(r)
}

/*
AansluitingenSectorenToestandPartialUpdate2 Method for AansluitingenSectorenToestandPartialUpdate2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @param nummer
 @return ApiAansluitingenSectorenToestandPartialUpdate2Request
*/
func (a *AansluitingenApiService) AansluitingenSectorenToestandPartialUpdate2(ctx context.Context, aansluitnummer string, nummer int32) ApiAansluitingenSectorenToestandPartialUpdate2Request {
	return ApiAansluitingenSectorenToestandPartialUpdate2Request{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
		nummer: nummer,
	}
}

// Execute executes the request
//  @return SectorToestand
func (a *AansluitingenApiService) AansluitingenSectorenToestandPartialUpdate2Execute(r ApiAansluitingenSectorenToestandPartialUpdate2Request) (*SectorToestand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SectorToestand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenSectorenToestandPartialUpdate2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/sectoren/{nummer}/toestand"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nummer"+"}", url.PathEscape(parameterToString(r.nummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSectorToestandRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenToestandPartialUpdateRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
	patchedAansluitingToestandRequest *PatchedAansluitingToestandRequest
}

func (r ApiAansluitingenToestandPartialUpdateRequest) PatchedAansluitingToestandRequest(patchedAansluitingToestandRequest PatchedAansluitingToestandRequest) ApiAansluitingenToestandPartialUpdateRequest {
	r.patchedAansluitingToestandRequest = &patchedAansluitingToestandRequest
	return r
}

func (r ApiAansluitingenToestandPartialUpdateRequest) Execute() (*AansluitingToestand, *http.Response, error) {
	return r.ApiService.AansluitingenToestandPartialUpdateExecute(r)
}

/*
AansluitingenToestandPartialUpdate Method for AansluitingenToestandPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenToestandPartialUpdateRequest
*/
func (a *AansluitingenApiService) AansluitingenToestandPartialUpdate(ctx context.Context, aansluitnummer string) ApiAansluitingenToestandPartialUpdateRequest {
	return ApiAansluitingenToestandPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return AansluitingToestand
func (a *AansluitingenApiService) AansluitingenToestandPartialUpdateExecute(r ApiAansluitingenToestandPartialUpdateRequest) (*AansluitingToestand, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AansluitingToestand
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenToestandPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/toestand"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedAansluitingToestandRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenTransitiesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
	patchedTransitionRequest *PatchedTransitionRequest
}

func (r ApiAansluitingenTransitiesPartialUpdateRequest) PatchedTransitionRequest(patchedTransitionRequest PatchedTransitionRequest) ApiAansluitingenTransitiesPartialUpdateRequest {
	r.patchedTransitionRequest = &patchedTransitionRequest
	return r
}

func (r ApiAansluitingenTransitiesPartialUpdateRequest) Execute() (*Aansluiting, *http.Response, error) {
	return r.ApiService.AansluitingenTransitiesPartialUpdateExecute(r)
}

/*
AansluitingenTransitiesPartialUpdate Method for AansluitingenTransitiesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenTransitiesPartialUpdateRequest
*/
func (a *AansluitingenApiService) AansluitingenTransitiesPartialUpdate(ctx context.Context, aansluitnummer string) ApiAansluitingenTransitiesPartialUpdateRequest {
	return ApiAansluitingenTransitiesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return Aansluiting
func (a *AansluitingenApiService) AansluitingenTransitiesPartialUpdateExecute(r ApiAansluitingenTransitiesPartialUpdateRequest) (*Aansluiting, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aansluiting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenTransitiesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/transities"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTransitionRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenTransitiesRetrieveRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
}

func (r ApiAansluitingenTransitiesRetrieveRequest) Execute() (*Transition, *http.Response, error) {
	return r.ApiService.AansluitingenTransitiesRetrieveExecute(r)
}

/*
AansluitingenTransitiesRetrieve Method for AansluitingenTransitiesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenTransitiesRetrieveRequest
*/
func (a *AansluitingenApiService) AansluitingenTransitiesRetrieve(ctx context.Context, aansluitnummer string) ApiAansluitingenTransitiesRetrieveRequest {
	return ApiAansluitingenTransitiesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return Transition
func (a *AansluitingenApiService) AansluitingenTransitiesRetrieveExecute(r ApiAansluitingenTransitiesRetrieveRequest) (*Transition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Transition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenTransitiesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/transities"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenUpdateRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
	aansluitingRequest *AansluitingRequest
}

func (r ApiAansluitingenUpdateRequest) AansluitingRequest(aansluitingRequest AansluitingRequest) ApiAansluitingenUpdateRequest {
	r.aansluitingRequest = &aansluitingRequest
	return r
}

func (r ApiAansluitingenUpdateRequest) Execute() (*Aansluiting, *http.Response, error) {
	return r.ApiService.AansluitingenUpdateExecute(r)
}

/*
AansluitingenUpdate Method for AansluitingenUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenUpdateRequest
*/
func (a *AansluitingenApiService) AansluitingenUpdate(ctx context.Context, aansluitnummer string) ApiAansluitingenUpdateRequest {
	return ApiAansluitingenUpdateRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return Aansluiting
func (a *AansluitingenApiService) AansluitingenUpdateExecute(r ApiAansluitingenUpdateRequest) (*Aansluiting, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Aansluiting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aansluitingRequest == nil {
		return localVarReturnValue, nil, reportError("aansluitingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aansluitingRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAansluitingenValidatieRetrieveRequest struct {
	ctx context.Context
	ApiService *AansluitingenApiService
	aansluitnummer string
}

func (r ApiAansluitingenValidatieRetrieveRequest) Execute() (*ValidationObject, *http.Response, error) {
	return r.ApiService.AansluitingenValidatieRetrieveExecute(r)
}

/*
AansluitingenValidatieRetrieve Method for AansluitingenValidatieRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aansluitnummer
 @return ApiAansluitingenValidatieRetrieveRequest
*/
func (a *AansluitingenApiService) AansluitingenValidatieRetrieve(ctx context.Context, aansluitnummer string) ApiAansluitingenValidatieRetrieveRequest {
	return ApiAansluitingenValidatieRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		aansluitnummer: aansluitnummer,
	}
}

// Execute executes the request
//  @return ValidationObject
func (a *AansluitingenApiService) AansluitingenValidatieRetrieveExecute(r ApiAansluitingenValidatieRetrieveRequest) (*ValidationObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidationObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AansluitingenApiService.AansluitingenValidatieRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/aansluitingen/{aansluitnummer}/validatie"
	localVarPath = strings.Replace(localVarPath, "{"+"aansluitnummer"+"}", url.PathEscape(parameterToString(r.aansluitnummer, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
